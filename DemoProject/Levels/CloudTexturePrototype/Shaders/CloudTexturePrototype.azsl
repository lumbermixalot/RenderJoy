
#include <RenderJoy/RenderJoyPassSrg.azsli>

// Based on https://www.shadertoy.com/view/3dVXDc
//An implementation of tileable 3D Perlin-Worley noise for modeling volumetric clouds
//inspired from the chapter Real-Time Volumetric Cloudscapes by Andrew Schneider
//(Guerrilla Games). The first column is the perlin-worley noise generated by remapping
//perlin noise with the lowest frequency worley fbm. The next 3 columns are worley fbms
//with increasing frequencies, and are used to model the cloud shapes which are rendered
//in the last column.

// Utility function that maps a value from one range to another.
// From GPU Pro 7. Chapter 4
float Remap(float value, float oldMin, float oldMax, float newMin, float newMax)
{
    return (((value - oldMin) / (oldMax - oldMin)) * (newMax - newMin)) + newMin;
}


// Screen coordinates orientation
// (0, 0)------>  (iResolution.x, 0)
//       |
//       |
//       |
// (0, iResolution.y)
PSOutput MainPS(VSOutput IN) // V2
{
    // Version2 does light calculation
    PSOutput OUT;

    float2 st = IN.m_position.xy / iResolution.xy;
    float2 uv = IN.m_position.xy / iResolution.y;
    st.x *= 5.0; //5 columns for different noises
    uv -= .02 * iTime;

    float3 color = 0.0;

    float perlinWorley = PassSrg::m_channel[0].Sample(PassSrg::LinearSampler, uv * 0.5).x;
    float3 worley = PassSrg::m_channel[0].Sample(PassSrg::LinearSampler, uv).yzw;
    float worleyFbm = worley.x * .625 +
        		      worley.y * .125 +
        		      worley.z * .25;


    // cloud shape modeled after the GPU Pro 7 chapter
    float cloud = Remap(perlinWorley, worleyFbm - 1., 1., 0., 1.);
    cloud = Remap(cloud, .5, 1., 0., 1.); // fake cloud coverage
    
    if (st.x < 1.)
        color += perlinWorley;
    else if(st.x < 2.)
        color += worley.x;
    else if(st.x < 3.)
        color += worley.y;
	else if(st.x < 4.)
        color += worley.z;
    else if(st.x < 5.)
        color += cloud;
            
    // column dividers
    float div = smoothstep(.01, 0., abs(st.x - 1.));
    div += smoothstep(.01, 0., abs(st.x - 2.));
	div += smoothstep(.01, 0., abs(st.x - 3.));
    div += smoothstep(.01, 0., abs(st.x - 4.));
        
    color = lerp(color, float3(0., 0., .866), div);
    

    OUT.m_color = float4(color, 1);

    return OUT;
}

