/*
* Copyright (c) Galib Arrieta (aka lumbermixalot@github, aka galibzon@github).
*
* SPDX-License-Identifier: Apache-2.0 OR MIT
*
*/

 // This is a cosmetic shader. Only useful to visualize a slice
 // of a Texure3D with gradient noise data.
 
#include <Atom/Features/ColorManagement/TransformColor.azsli>
//#include <Atom/Features/SrgSemantics.azsli>
#include <scenesrg.srgi>
#include <viewsrg.srgi>

float3 GetVertexModelPosition(uint vertexId, float heightToWidthRatio)
{
    // If you use your right hand
    // these trinagles are facing in Y+ direction, 
    // 3 2---0  
    // | \\  |
    // |  \\ |
    // 5---4 1
    const float3 expansion[6] =
    {
        float3( 1, 0,  heightToWidthRatio),
        float3( 1, 0, -heightToWidthRatio),
        float3(-1, 0,  heightToWidthRatio),
        float3(-1, 0,  heightToWidthRatio),
        float3( 1, 0, -heightToWidthRatio),
        float3(-1, 0, -heightToWidthRatio)
    };

    return expansion[vertexId]; //* PerDrawSrg::m_starParams.m_scale;
}

float2 GetVertexTextureCoord(uint vertexId)
{
    const float2 texcoord[6] = 
    { 
        float2(0, 0), 
        float2(0, 1),
        float2(1, 0),
        float2(1, 0),
        float2(0, 1),
        float2(1, 1)    
    };

    return texcoord[vertexId];
}

ShaderResourceGroup PassSrg : SRG_PerPass
{
    // If false, renders as a billboard floating in the world.
    bool m_isFlatscreenMode;

    // These two apply only if rendering as a billboard.
    bool m_alwaysFaceCamera;
    row_major float4x4 m_modelToWorld;

    // These apply only in Flatscreen mode.
    float4 m_flatscreenLayout; //x, y, width, height

    Texture2D<float4> m_inputTexture; // A texture generated by a RenderJoy pipeline.
    Sampler LinearSampler
    {
        MinFilter = Linear;
        MagFilter = Linear;
        MipFilter = Linear;
        AddressU = Mirror;
        AddressV = Mirror;
        AddressW = Mirror;
    };

    float4 GetWorldPosition(float3 modelPosition)
    {
        if (m_alwaysFaceCamera)
        {
            const float3 myWorldPos = m_modelToWorld._m03_m13_m23;

            // Need to preserve the scale.
            float3 r = m_modelToWorld._m00_m10_m20;
            float3 f = m_modelToWorld._m01_m11_m21;
            float3 u = m_modelToWorld._m02_m12_m22;
            float3 scale = float3(length(r), length(f), length(u));

            const float3 cameraPos = ViewSrg::m_worldPosition;
            float3 myForward = normalize(cameraPos - myWorldPos);
            // Recreate Up and Right vectors.
            float3 myRight = cross(myForward, float3(0, 0, 1.0));
            float3 myUp = cross(myRight, myForward);

            myRight *= scale.x;
            myForward *= scale.y;
            myUp *= scale.z;
            const row_major float4x4 tm = {
                myRight.x, myForward.x, myUp.x, myWorldPos.x,
                myRight.y, myForward.y, myUp.y, myWorldPos.y,
                myRight.z, myForward.z, myUp.z, myWorldPos.z,
                        0,           0,      0,            1.0,
            };
            return mul(tm, float4(modelPosition, 1));
        }

        return mul(m_modelToWorld, float4(modelPosition, 1));
    }

    float4 GetBillboardClipCoordinates(const uint vertexIndex)
    {
        // Calculate width to height ratio of the billboard based on the texture
        // dimensions.
        uint2 texDims;
        m_inputTexture.GetDimensions(texDims.x, texDims.y);
        const float heightToWidthRatio = float(texDims.y) / float(texDims.x);
        // First, get the "model" position from the VertexId
        const float3 vertexModelPosition = GetVertexModelPosition(vertexIndex, heightToWidthRatio);
        //float3 vertexWorldPosition = vertexModelPosition;//mul(PerDrawSrg::m_modelToWorld, float4(vertexModelPosition, 1));
        const float4 vertexWorldPosition = PassSrg::GetWorldPosition(vertexModelPosition);
        return mul(ViewSrg::m_viewProjectionMatrix, vertexWorldPosition);
    }

    float4 GetFlatscreenClipCoordinates(const uint vertexIndex)
    {
        // Just like a regular bitmap the cell row goes from
        // 0 (top edge) to m_numRows-1 (bottom edge)
        //const float cellWidth = 2.0 / float(m_numColumns);
        //const float cellHeight = 2.0 / float(m_numRows);
        //const float cellPosX = -1.0 +  cellWidth * m_column;
        //const float cellPosY = 1.0 - cellHeight * m_row;


        const float cellWidth = m_flatscreenLayout.z * 2.0f;
        const float cellHeight = m_flatscreenLayout.w * 2.0f;
        const float cellPosX = -1.0 +  m_flatscreenLayout.x * 2.0f;
        const float cellPosY = 1.0 - m_flatscreenLayout.y * 2.0f;

        const float nearZdepth = 1.0; // Atom uses reverse Zdepth where 0.0 is far.
        const float4 expansion[6] =
        {
            // Fullscreen clip coordinates
            //X = [-w (left edge), w (right edge)]
            //Y = [-w (bottom edge), w (top edge)]
            // 0---2 3 
            // |  / /|
            // | / / |
            // 1/ 4--5
            //float4( -1,  1, nearZdepth, 1.),
            //float4( -1, -1, nearZdepth, 1.),
            //float4(  1,  1, nearZdepth, 1.),
            //float4(  1,  1, nearZdepth, 1.),
            //float4( -1, -1, nearZdepth, 1.),
            //float4(  1, -1, nearZdepth, 1.)
            float4( cellPosX,             cellPosY,              nearZdepth, 1.),
            float4( cellPosX,             cellPosY - cellHeight, nearZdepth, 1.),
            float4( cellPosX + cellWidth, cellPosY,              nearZdepth, 1.),
            float4( cellPosX + cellWidth, cellPosY,              nearZdepth, 1.),
            float4( cellPosX,             cellPosY - cellHeight, nearZdepth, 1.),
            float4( cellPosX + cellWidth, cellPosY - cellHeight, nearZdepth, 1.)
        };

        return expansion[vertexIndex]; //* PerDrawSrg::m_starParams.m_scale;
    }

    // As vertex shaders are supposed to do, returns the Clip Space(aka Homogenous Clip Space) coordinates
    // in the range (-w,-w, 0) - (w, w, w)  
    float4 GetVertexClipCoordinates(const uint vertexIndex)
    {
        return m_isFlatscreenMode ? GetFlatscreenClipCoordinates(vertexIndex) : GetBillboardClipCoordinates(vertexIndex);
    }
}

struct VSInput
{
    uint m_vertexID : SV_VertexID;
};

struct VSOutput
{
    float4 m_position : SV_Position;
    float2 m_texCoord : TEXCOORD;
};

VSOutput MainVS(VSInput IN)
{
    VSOutput OUT;

    const uint vertexIndex = uint(IN.m_vertexID) % uint(6);
    OUT.m_position = PassSrg::GetVertexClipCoordinates(vertexIndex);
    OUT.m_texCoord = GetVertexTextureCoord(vertexIndex);
    return OUT;
};

struct PSOutput
{
    float4 m_color : SV_Target0;
};

PSOutput MainPS(VSOutput IN)
{
    PSOutput OUT;

    const float2 texCoord = IN.m_texCoord.xy;

    float4 color = PassSrg::m_inputTexture.Sample(PassSrg::LinearSampler, texCoord).rgba;

    //float invGamma = 2.2;
    //color.rgb = pow(color.rgb, float3(invGamma, invGamma, invGamma));

    color.rgb = TransformColor(color.rgb, ColorSpaceId::LinearSRGB, ColorSpaceId::ACEScg);
    //color.rgb = TransformColor(color.rgb, ColorSpaceId::LinearSRGB, ColorSpaceId::SRGB);
    //color.rgb = HsvToRgb(color.rgb);
    color.a = 1.0;

    OUT.m_color = color;

    //OUT.m_diffuse = float4(1, 0, 0, 1);
    //OUT.m_diffuse = float4(0, 0, 1.0, 1);

    return OUT;
}; 
