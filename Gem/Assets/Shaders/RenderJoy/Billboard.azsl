/*
* Copyright (c) Galib Arrieta (aka lumbermixalot@github, aka galibzon@github).
*
* SPDX-License-Identifier: Apache-2.0 OR MIT
*
*/

 // This is a cosmetic shader. Only useful to visualize a slice
 // of a Texure3D with gradient noise data.
 
#include <Atom/Features/ColorManagement/TransformColor.azsli>
//#include <Atom/Features/SrgSemantics.azsli>
#include <scenesrg.srgi>
#include <viewsrg.srgi>

ShaderResourceGroup PassSrg : SRG_PerPass
{
    row_major float4x4 m_modelToWorld;

    bool m_alwaysFaceCamera;

    Texture2D<float4> m_inputTexture; // A texture generated by a RenderJoy pipeline.
    Sampler LinearSampler
    {
        MinFilter = Linear;
        MagFilter = Linear;
        MipFilter = Linear;
        AddressU = Mirror;
        AddressV = Mirror;
        AddressW = Mirror;
    };

    float4 GetWorldPosition(float3 modelPosition)
    {
        if (m_alwaysFaceCamera)
        {
            const float3 myWorldPos = m_modelToWorld._m03_m13_m23;

            // Need to preserve the scale.
            float3 r = m_modelToWorld._m00_m10_m20;
            float3 f = m_modelToWorld._m01_m11_m21;
            float3 u = m_modelToWorld._m02_m12_m22;
            float3 scale = float3(length(r), length(f), length(u));

            const float3 cameraPos = ViewSrg::m_worldPosition;
            float3 myForward = normalize(cameraPos - myWorldPos);
            // Recreate Up and Right vectors.
            float3 myRight = cross(myForward, float3(0, 0, 1.0));
            float3 myUp = cross(myRight, myForward);

            myRight *= scale.x;
            myForward *= scale.y;
            myUp *= scale.z;
            const row_major float4x4 tm = {
                myRight.x, myForward.x, myUp.x, myWorldPos.x,
                myRight.y, myForward.y, myUp.y, myWorldPos.y,
                myRight.z, myForward.z, myUp.z, myWorldPos.z,
                        0,           0,      0,            1.0,
            };
            return mul(tm, float4(modelPosition, 1));
        }

        return mul(m_modelToWorld, float4(modelPosition, 1));
    }
}

struct VSInput
{
    uint m_vertexID : SV_VertexID;
};

struct VSOutput
{
    float4 m_position : SV_Position;
    float2 m_texCoord : TEXCOORD;
};

float3 GetVertexModelPosition(uint vertexId)
{
    // 0---2 3 
    // |  / /|
    // | / / |
    // 1/ 4--5
    const float3 expansion[6] =
    {
        float3( 1, 0,  1),
        float3( 1, 0, -1),
        float3(-1, 0,  1),
        float3(-1, 0,  1),
        float3( 1, 0, -1),
        float3(-1, 0, -1)
    };

    return expansion[vertexId]; //* PerDrawSrg::m_starParams.m_scale;
}

float2 GetVertexTextureCoord(uint vertexId)
{
    const float2 texcoord[6] = 
    { 
        float2(0, 0), 
        float2(0, 1),
        float2(1, 0),
        float2(1, 0),
        float2(0, 1),
        float2(1, 1)    
    };

    return texcoord[vertexId];
}



VSOutput MainVS(VSInput IN)
{
    VSOutput OUT;

    const uint vertexIndex = uint(IN.m_vertexID) % uint(6);
    
    // First, get the "model" position from the VertexId
    float3 vertexModelPosition = GetVertexModelPosition(vertexIndex);
    //float3 vertexWorldPosition = vertexModelPosition;//mul(PerDrawSrg::m_modelToWorld, float4(vertexModelPosition, 1));
    float4 vertexWorldPosition = PassSrg::GetWorldPosition(vertexModelPosition);
    OUT.m_position = mul(ViewSrg::m_viewProjectionMatrix, vertexWorldPosition);
    OUT.m_texCoord = GetVertexTextureCoord(vertexIndex);
    return OUT;
};

struct PSOutput
{
    float4 m_color : SV_Target0;
};

PSOutput MainPS(VSOutput IN)
{
    PSOutput OUT;

    const float2 texCoord = IN.m_texCoord.xy;

    float4 color = PassSrg::m_inputTexture.Sample(PassSrg::LinearSampler, texCoord).rgba;

    //float invGamma = 2.2;
    //color.rgb = pow(color.rgb, float3(invGamma, invGamma, invGamma));

    color.rgb = TransformColor(color.rgb, ColorSpaceId::LinearSRGB, ColorSpaceId::ACEScg);
    //color.rgb = TransformColor(color.rgb, ColorSpaceId::LinearSRGB, ColorSpaceId::SRGB);
    //color.rgb = HsvToRgb(color.rgb);
    color.a = 1.0;

    OUT.m_color = color;

    //OUT.m_diffuse = float4(1, 0, 0, 1);
    //OUT.m_diffuse = float4(0, 0, 1.0, 1);

    return OUT;
}; 
